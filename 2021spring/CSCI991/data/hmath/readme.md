
## 数据说明
数据来源于网络资源中，包括百度百科、百度文库、维基百科等包含学科知识点的语句。
数学、物理学科由于含有公式，因此涉及公式的句子可能语法上读不通，但不妨碍模型的训练学习；
文件中包含原始数据集样本（context_entity），实体（entity），训练集（train_data），测试集（test_data）以及实体关系数据库sql文件；
1. 数据集样本（context_entity）：每一行代表一个样本，每个样本包含两部分，一部分为原始句子，一部分为该句子的所有实体。实体是按照其在句子中首次出现的位置排序而成。格式例如：

> 平方根是开方运算的基础，是引入无理数的准备知识。 平方根,开方,无理数
2. 实体（entity）：包含该数据集涉及的所有实体，即知识点。实体分为两类，``1`` 表示该学科切实存在的实体，例如``三角形``、``对数函数``等，标注符号为``KNOW``，``2``表示该学科的定理、定律、法则、求解方法等逻辑概念，例如``点差法``、``正弦定理``等，标注符号为``PRIN``。
3. 训练集和测试集（train_data和test_data）：本人通过程序将数据集按照out of beg抽样方法将context_entity划分训练集合测试集，测试集为袋外样本。两个文件格式如图所示：
在这里插入图片描述

关系种类：本人设计知识点的关系一共12种，如下表：
序号	英文符号	关系名称	说明
1	rely	依赖	某个知识点依赖于另一个知识点，两个知识点有必要的前后顺序关系，或者某个知识点的存在必须依赖于另一个知识点的存在
2	b-rely	被依赖	某个知识点被依赖于另一个知识点，两个知识点有必要的前后顺序关系
3	belg	属于	某个知识点内容从属于另一个知识点范畴内
4	b-belg	包含	某个知识点包含另一个知识点内容
5	syno	同义	两个知识点名称不同但指代同一个内容
6	anto	反义	两个知识点意义相反
7	simi	近义	两个知识点有相似的内容
8	attr	属性	某个知识点（或名词）是另一个知识点的属性，例如``面积``和``矩形``
9	b-attr	拥有	某个知识点拥有的属性是另一个知识点
10	Appo	同位	两个知识点在一定范围内具有相同的父节点
11	other	其他	两个知识点具备其他关系
12	none	无关	两个知识点没有关系
标注规则
  在命名实体识别任务中，需要有标注过的数据集，按照绝大多数的科研标注规范，以B表示该实体中首字符的标识，I表示该实体其他字符的标识。若该词只有一个字则仅为B。例如``三角形``标注为``B-KNOW I-KNOW I-KNOW``，而``正弦定理``则标注为``B-PRIN I-PRIN I-PRIN``。

  备注：因为该数据为人工标注，因此在数据集中的sql数据库中，relation_id=12代表``无关``，同时两个实体若没有关系记录的默认为``无关``。当然存在两个实体从来没有组成对，但它们有关联的这种的可能，因此这部分数据需要进行实体链接和知识推理步骤完成。

三、数据使用
  数据在训练时使用train_data文件，例如使用python代码需要先读取文件，再对每一个样本划分两个部分：原始句子sentence和该句子的所有实体entitys。
(1) 读取数据集：

with open('./context_entity','r',encoding="utf-8") as f:
    for i in f.readlines():
        sentence , entitys = i.split(' ')
1
2
3
(2) 数据集标注：

def getTag(dataset):
    #根据数据集原始样本及对应所有实体，进行序列标注，生成已标注的样本
    #参数：dataset：已读取的数据集
    #返回格式： [ ['原始样本','原始样本的序列标注序列'],... ]
    entity_dict = readEntitys()
    context_tag = []
    for i in dataset:
        raw_context = i[0]
        entitys = i[1]
        tag = ['O']*len(raw_context)
        entitys.sort(key=lambda x: len(x))
        entitys.reverse()
        for j in entitys:
            label = kind_dict[entity_dict[j]]
            label_start = 'B-' + label
            label_ = 'I-' + label            
            for k in re.finditer(j,raw_context):
                if 'O' in tag[k.start():k.end()]:
                    tag[k.start():k.end()]=[label_start] + [label_]*(len(j)-1)
        context_tag.append([raw_context,tag])
    return context_tag
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(3) 实验测试：
  本人暂时仅进行了命名实体识别的测试，模型采用BiLSTM+CRF+word2vec，以初中和高中数学测试集为例，相应的精度、召回率和F1值如下：

序号	数据集	结果
1	初中数学	在这里插入图片描述
2	高中数学	在这里插入图片描述
(4)应用测试：
在这里插入图片描述
  备注：数据可能存在一些噪声，因为在对每一个样本进行实体标注时是采用模式匹配实现的，可能存在标注错误问题，例如对于句子``一元二次方程组成的方程组是一元二次方程组``，很容易把前头的``一元二次方程``标注为``一元二次方程组``，而这里的``组``应该与``成``字为``组成``。类似的问题可能会存在，大家下载后可以再做更细的处理。

四、自定义创建数据集
  授人以鱼不如授人以渔，简单教大家如何制作这一类的数据集，简要概括如下：

确定学科领域的范围。例如确定初中数学学科的知识范围为人教版。
搜集相关的知识点。例如初中数学内有知识点``全等三角形``，而高中数学里面有``导数``等。
通过百科、文档或者网页爬取等方式获取句子级别的数据，简单进行清理后组成数据集。
首先通过已搜集的实体对每一个句子进行模式匹配，搜索出每个句子中所有的实体。
对每个句子的每个实体进行检查，并为每一个实体对划分关系类别。这一步骤可通过web程序实现，已分过的实体对下一次就不用重新划分了。

###
数据集说明：
1、最终原始数据：context_entity
格式：  样本 实体1，实体2，..
2、最终实体表：entity
格式：  实体 类型（1,2）
3、最终实体关系表：详见数据库文件``高中数学.sql``请用SQL语言读取数据。
数据库中包括所有实体的关系，所有样本以及实体，所有关系（一共12个关系）。其中entity数据表可以忽略。
4、本人以通过out of bag方法随机划分了训练集和测试集，当然也可以自己设计算法划分。
最终训练集和测试集分别为train_data test_data